
#include <iostream>

using namespace std;

// > cpp 中的空指针
// ------------------------------------------------------------
//  C 和 C++中使用 0 或 NULL 都可以表示空指针, 声明指针之后，在
//  赋值之前，让塔指向空，表示没有指向任何地址
// --------------------
// > 使用空指针的后果
//   1. 如果对空指针解引用，程序会崩溃
//   2. 如果对空指针使用 delete 运算符，系统将忽略该操作，不会出现异常
//      所以内存被释放后，也应该把指针指向空.
// -------------------
// > 为什么空指针访问会出现异常？
//
//  NULL 指针分配的分区，其范围是0x00000000 到 0x0000FFFF. 这段空间是空闲的，
//  对于空闲的空间按而言，没有相应的物理存储器与之相对应，所以对这段空间来说
//  任何读写操作都是会引起异常的，空指针是程序无论在何时都没有物理存储器与之
//  对应的地址，为了保障 '无论何时' 这个条件, 需要人为的划分一个空指针的区域
//  固有上面 NULL 指针分区.
//
// --------------------
// > C++ 11 的 nullptr (linux 平台编译需要加 -std=c++11 参数)
//
// 用 0 和 NULL表示空指针会产生歧义，C++11 建议使用 nullptr 表示空指针，也就是
// (void*) 0. NUll 在 C++ 中就是 0，这是因为 C++ 中 void* 类型是不允许隐式转换
// 为其他类型的，所以之前 C++ 中使用 0 来代表空指针，但是在重载整形的情况下，会
// 出现上述的问题，所以，C++11 加入了 nullptr, 可以保证在任何情况下都代表空指针
// 而不会出现上述的情况，因此，建议使用 nullptr 替代 NULL, 而 NULL 就当作0 使用
//

void make_null_point() {
  // 使用0 / NULL 都表示空指针
  int *p = 0;

  int *o = nullptr;

  // 对空指针解引用程序异常终止
  // cout << "*p=" << *p << endl;

  // 对空指针使用 delete
  delete p;
  cout << "delete ok" << endl;
}

void express(int *no, string *message) {

  // 当传入的参数类型为指针型变量，应该增加判断是否为空指针的代码
  // 目的是保证程序的健壮性
  if (no == 0 || message == 0) {
    return;
  }
  cout << "no= " << *no << ", message = " << *message << endl;
}

void null_ptr() {

  make_null_point();

  //
}
