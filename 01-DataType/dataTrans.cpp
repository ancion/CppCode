
#include <iostream>

using namespace std;

// C++ 中的数据转换
// -----------------------------------------------------------------------------
//  计算机在进行运算时，要求各操作数的数据类型具有相同的大小和存储方式, 但实际
//  开发过程中多种数据类型进行混合运算是比较常见的。
//
//  > 自动类型转换, 某些类型的转换编译器可以隐式的进行，不需要程序员干预
//    - 不同的数值类型差别在于取值范围与精度（数据的取值范围越大，精度越高）
//    - 我们在运算时出现混合时，较低类型会自动向较高类型转换
//    - 当表达式中出现了浮点型操作数时，所有操作数都将转换为浮点型
//    - 赋值运算的右值类型与左值类型不同时，将右值 提升/ 降低 为左值类型
//    - 赋值运算右值超出左值类型的范围，把右值截断赋值给左值。结果可能毫无意义
//
//  > 强制类型转换, 有些类型的转换需要程序员显示指定 
//    -  （type）variable 或者 type(variable)
//    - 如果使用了强制类型转换，表示程序员已有明确目的
//    - 如果转换的行为不合理，后果由程序员自行承担
//    - 如果采用强制类型转换，编译的告警信息将不再出现
//    - 类型转换运算符的优先级比较高，没把握就加括号
//
//

void auto_trans() {

  char a = 10;
  int b = 102400;
  long long c = 12332553521234234;

  // 低类型向高类型转换
  cout << "a+b+c=" << a + b + c << endl;

  // 当表达式中含又浮点型操作数时，所有操作数都将转换为浮点型
  cout << "8.5 / 5 = " << (8.0 / 5) << endl;

  // 赋值时数据类型不匹配直接降级或者升级
  char x = 'X';
  cout << x << endl;

  // (double) -> int (小数部分将丢失)
  int y = 123.34535;
  cout << y << endl;

  // 精度丢失(超出取值范围将被截断, 超出的高位被截断)
  unsigned int e = 4294967295 + 2;
  cout << "e = " << e << endl;
}

// 强制直接转换
void force_trans() {

  // 强制转换然后告警消失了
  int y = (int) 123.34535;

}

int main() {
  // 隐式自动转换
  auto_trans();

  // 强制直接转换
  force_trans();

  return 0;
}
