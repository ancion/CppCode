
#include <cstdlib>
#include <cstring>
#include <iostream>
using namespace std;

// cpp 中的数组
// -----------------------------------------------------------
// > 数组是一组数据类型相同的变量存储在一起
//  1. 创建数组语法 数据类型， 数组名称[数据长度]
//     数据的长度必须是整数，可以是常量，可以是变量或者表达式
//     (
//       > C90 中规定必须使用常量表达式定义数组的大小
//       > C99 中允许使用整形非常量表达式
//       > VS 中可以使用整形非常量表达式
//       > Linux 中还可以使用整形变量
//     )
//  2. 数据的使用
//    > 数组使用下标来访问元素，数组下标从 0 开始
//    > 数组中的每个元素的特征和使用方法与单个变量完全相同
//    > 数组长度的取值是[0~(length-1)]
//
//  3. 数组内存
//    > 数组在内存中占用空间是连续的
//    > 可以使用 sizeof(数组名) 可以得道整个数据占用内存空间的大小
//      这种方式只能适用于 C++ 的基本数据类型
//
//  4. 数组的初始化
//
//    > 直接使用 int arr[] = {} 完成数组的初始化赋值
//    > 可以直接对内部元素赋值，当 {} 为 0 或者空白的时候数组被全部初始化为0
//
//  5. 清空数组
//      > 调用函数 void * memset(void *s, int c, size_t n);
//      > Linux 下使用 memset() 需要包含头文件 <csting> -> <string.h>
//
//  6. 复制数组
//      > memcpy() 函数可以把数组中全部的元素复制到另一个相同大小的数组
//        只适用于 C++ 基本数据类型
//      > 函数原型 void *memcpy(void *dest, const void *src, size_t n);
//      > Linux 下使用 memset() 需要包含头文件 <csting> -> <string.h>
//
// ---------------------------------------------------------------------
// > 数组指针
//
//  1. 指针的算数
//    - 将一个整形变量加1后, 其值将加1.
//    - 但是，将指针变量(地址的值) 加1 后, 增加的量等于它指向的数据类型的字节数
//      也就是数组中下一个元素的位置
//  2. 数组的地址
//    - 数组在内存中占用的空间是连续的
//    - C++ 将数组名解释为数组第 0 个元素的地址
//    - 数组第 0 个元素的地址和数组首地址的取值是相同的.
//    - 数组中第 n 个元素的地址是: 数组的首地址 + n
//    - C++ 编译器把 数组名[index] 解释为 *(数组首地址 + 下标)
//  3. 数组的本质
//    数组是占用连续空间的一块内存，数组名被解释为数组第一个元素的地址，
//    C++ 操作这块内存有两种方法，数组解释法和指针表示法，他们是等价的
//
//  4. 数组名不一定会被解释为地址
//    在多数情况下，C++ 将数组名解释为数组的第一个元素的地址，但是, 将
//    sizeof 元算符用于数据名时，将放回整个数组占用内存空间的字节数
//    __可以修改指针的值，但数组名是常量，不可修改__
//
// -------------------------------------------------------------------------
//  > 用作函数参数
//   1. 在函数中使用数组参数时，可以使用数组表示法，也可以使用指针表示法
//   2. 一维数组用于函数的参数时，只能传递数组地址，并且必须把数组长度传入函数，
//      除非数组中有最后一个元素的标志.
//   3. 在函数中，不要对指针名使用sizeof运算符，它不是数组名
//
// -------------------------------------------------------------------------
// > 使用 new-delete (动态创建数组和释放对象)普通的数组在栈上分配内存，
//   栈空间很小，如果需要存放更多的元素，必须在堆上分配内存空间
//   1.动态创建的数组没有数组名，不能用sizeof 关键字
//   2.可以用数组表示法和指针表示法两种方式使用动态创建的数组
//   3.必须使用 delete[] 来释放内存 (不能只使用 delete)
//   4.不要用delete[]来释放不是new[]分配的内存(malloc 等C语言的方法,栈上内存等)
//   5.不要用delete[]来释放同一个内存块两次(否则等同于操作野指针)
//   6.对空指针用 delete[] 是安全的(释放内存后，应该把指针置空)
//   7.声明普通数组的时候，数组长度可以使用变量，相当于在栈上动态创建数组
//     并且不用释放
//   8.如果内存不足，调用new会产生异常，导致程序终止，如果在 new 关键字后
//     添加 (std::nothrow) 选项，则返回 nullptr, 不会产生异常
//   9.为什么使用 delete[]
//   释放内存的时候不需要指定数组的大小，因为系统会自动追踪
//      已分配的内存，
// -------------------------------------------------------------------------
// > 数组的排序
//   -> C++ 中的 qsort 函数支持多种数据类型的排序
//   qsort(
//      void *base,          // 数组(void *) 支持多种数据类型,使用时传具体类型
//      size_t nmemb,        // 数组的长度
//      size_t size,         // 数组元素的大小
//      __compar_fn_t compar // 数据比对的回调函数(元素的排序逻辑自定义)
//   )
//
// ------------------------------------------------------------------------
// > 数组的排序
//
//

// -------------------------------------------------------------------------
// 二分查找
// -------------------------------------------------------------------------
//
//
//
// ------------------------------------------------------------------------
// 二维数组 (对应数学中的矩阵)
//
// 二维数组的使用与一维数组没有什么本质上的区别，只是多了一个维度，使用两个
// 下标来表示具体的元素的位置，第一个表示行，第二个表示列.
//
//  1.可以进行对应值的读取，赋值, 内存地址等操作与一维数组都是类似的
//  2.使用sizeof(数组名) 可以得到整个二维数组占用空间的大小(C++基本类型)
//  3.二维数组在内存中占用的空间是连续的(内存存储都是一维线性的)
//
// --------------------
//  > 二维数组初始化赋值
//
//  int bh[2][3] = {{10,11,12}, {20,21,22}};
//  int bh[2][3] = {10, 11, 12, 20, 21, 22};
//  int bh[][3] = {10, 11, 12, 20, 21, 22};
//  int bh[][3] {10, 11, 12, 20, 21, 22}; // C++11 标准
//
// --------------------
//  > 二维数组清空存储值
//
//  memset(void* s, int c, size_t n);
//
//  memset() 函数只适用与 C++ 基本类型，可以把二维数组中的全部元素清零
//
// --------------------
// > 二维数组的拷贝
//
// void memcpy(void* dest, const void* src, size_t n);
// 
// memcpy 函数可以把二维数组中全部的元素复制到另一个相同大小的数组(无论几维)
// 只能适用于 C++ 的基本类型, n 表示复制的字节数
//
// --------------------
// > 二维数组作为参数
//
//
//
// -------------------
// > 行指针

void level_array() {
  int bh[2][3];

  bh[0][0] = 11;
  bh[0][1] = 12;
  bh[0][2] = 13;
  bh[1][0] = 21;
  bh[1][1] = 22;
  bh[1][2] = 23;

  cout << "bh[0][0] = " << bh[0][0] << "bh[0][1] = " << bh[0][1]
       << "bh[0][2] = " << bh[0][2] << endl;
  cout << "bh[1][0] = " << bh[1][0] << "bh[1][1] = " << bh[1][1]
       << "bh[1][2] = " << bh[1][2] << endl;

  // 使用遍历的方式来完成输出
  for (int row = 0; row < 2; row++) {
    for (int column = 0; column < 3; column++) {
      cout << "bh[" << row << "]"
           << "[" << column << "]=" << bh[row][column] << " ";
    }
    cout << endl;
  }

  // 我们使用指针来操作这个二维数组，验证内部存储的实质
  int *p = (int *)bh;

  for (int i = 0; i < 6; i++) {
    cout << "p[" << i << "] = " << p[i] << endl;
  }

  // 清空数组值为 0
  memset(bh, 0, sizeof(bh));
}

//
// > 二分查找的前提是数据是排好序的
// 如果在数组中找到了目标值key, 则返回 key 在数组中的下标
// 如果没有找到则返回 -1
int search(int arr[], int len, int key) {
  int low = 0, high = len - 1, mid;

  while (low <= high) {
    mid = (low + high) / 2; // 计算 mid 指针的位置
    if (arr[mid] == key)
      return mid;
    else if (arr[mid] > key)
      high = mid - 1; // 继续在前半区查找
    else
      low = mid + 1;
  }
  return -1;
}

void binary_search() {

  // 需要一个已经排好序的数组
  int a[10] = {7, 9, 12, 16, 21, 25, 30, 35, 41, 48};
  // 接收查找结果
  int val = search(a, 10, 30);
  if (val >= 0) {
    cout << "找到的30在数组中的索引是: " << val << endl;
  } else {
    cout << "没有找到目标元素" << endl;
  }
}

// -------------------------------------------------------------------------
// sort 排序
// -------------------------------------------------------------------------

// 回调函数的要求
// 1) 如果函数的返回值 < 0, 那么 a指向的元素会被排在b指向元素的前面
// 2) 如果函数的返回值 = 0, 那么 a指向的元素与b指向元素的顺序不确定
// 3) 如果函数的返回值 > 0, 那么 a指向的元素会被排在b指向元素的后面

// 升序
int compasc(const void *a, const void *b) { return *(int *)a - *(int *)b; }
// 降序
int compdesc(const void *a, const void *b) { return *(int *)b - *(int *)a; }

void sort_func() {

  int a[8] = {4, 2, 7, 5, 8, 1, 3, 6};

  for (int i = 0; i < (sizeof(a) / sizeof(int)); i++) {
    cout << "a[" << i << "] = " << a[i] << endl;
  }

  // 升序排列
  qsort(a, sizeof(a) / sizeof(int), sizeof(int), compasc);

  for (int i = 0; i < (sizeof(a) / sizeof(int)); i++) {
    cout << "a[" << i << "] = " << a[i] << endl;
  }

  // 降序排列
  qsort(a, sizeof(a) / sizeof(int), sizeof(int), compdesc);

  for (int i = 0; i < (sizeof(a) / sizeof(int)); i++) {
    cout << "a[" << i << "] = " << a[i] << endl;
  }
}

// -------------------------------------------------------------------------
// new - delete
// -------------------------------------------------------------------------

void warn() {

  // 这样声明的数组直接分配在栈上
  // 能存储的数组量有限，不需要释放
  int a[100];
  a[99] = 10;

  // 动态分配到堆上
  // 使用 std::nothrow 防止分配内存超过可使用的范围导致程序异常退出
  int *arr = new (std::nothrow) int[1000];
  if (arr == nullptr) {
    cout << "分配内存失败" << endl;
  } else {
    cout << "分配成功" << endl;
    // 继续逻辑
    delete[] arr;
  }
}

void new_delete() {

  // 创建长度为 8 的int 数据的语法
  int *arr = new int[8];

  // 赋值
  for (int i = 0; i < 8; i++) {
    arr[i] = 100 + i;
    cout << "arr[" << i << "] = " << *(arr + i) << endl;
  }

  // 释放空间 (必须使用 delete[], 不能仅仅使用 delete)
  delete[] arr;
}

// -------------------------------------------------------------------------
// 作为函数参数
// -------------------------------------------------------------------------

// 由于此时无法通过数组指针计算出长度，需要传入长度
void quick(int *arr, int len) {

  // 此时 arr 表示的是指针地址，无法计算出数组所占用的空间的大小
  cout << sizeof(arr) << endl;
  for (int i = 0; i < len; i++) {
    // 使用数组表示法
    cout << "arr[" << i << "] = " << arr[i] << endl;
    // 使用指针表示法
    cout << "*(arr +" << i << ") = " << *(arr + i) << endl;
  }
}

void array_ptr_param() {
  int a[5] = {1, 3, 5, 9, 19};

  // 此时可以用数组名来计算所占用的空间
  cout << sizeof(a) << endl;

  quick(a, sizeof(a) / sizeof(int));
}

//-----------------------------------------------------------------------
// 指针相关
//-----------------------------------------------------------------------

void more_ptr() {

  int a[5] = {1, 2, 4, 45, 6};

  int *p = a;

  for (int i = 0; i < 5; i++) {
    cout << "*(p+" << i << ") = " << *(p + i)
         << endl; // 数组名[下标] 解释为 *(数组首地址+下标)
    cout << "p[" << i << "] = " << p[i]
         << endl; // 地址[下标] 解释为 *(地址 + 下标)
  }

  cout << "_________________________________" << endl;

  int *k = &a[2]; // 第三个元素的地址
  // 获取的地址使用起来就像是一个新数组
  cout << p[0] << endl; // 表示原数组的第三个元素
  cout << p[1] << endl; // 表示原数组的第四个元素
  cout << p[2] << endl; // 表示原数组的第五个元素
}

// linux 中如果数组越界并不会报错
// 但是越界的数据会出现一些不是预期的结果
void out_of_index() {

  int arr3[] = {1, 2, 3, 4, 3, 5};

  for (int i = 0; i < 8; i++) {
    cout << "a[" << i << "]= " << arr3[i] << endl;
  }
  int *p = arr3;

  // 即使我们将数组下标从负数开始计算，同样不会报错
  // 按内存地址排布, 可以看出 C++ 将索引结束为指针
  for (int i = -2; i < 8; i++) {
    cout << "*p(" << i << ") = " << (p + i) << endl;
  }
}

// 数组指针的本质
void ptr_tran_index() {

  int a[5] = {1, 3, 10, 4, 1};

  cout << "a val is : " << (long)a << endl;
  cout << "&a val is : " << (long)&a << endl;
  cout << "a[0] address val is : " << &a[0] << endl;
  cout << "a[1] address val is : " << &a[1] << endl;
  cout << "a[2] address val is : " << &a[2] << endl;
  cout << "a[3] address val is : " << &a[3] << endl;
  cout << "a[4] address val is : " << &a[4] << endl;

  int *p = a;

  cout << "p val is : " << (long)p << endl;
  cout << "&p val is : " << *p << endl;
  cout << "p[0] val is : " << *(p + 0) << endl;
  cout << "p[1] val is : " << *(p + 1) << endl;
  cout << "p[2] val is : " << *(p + 2) << endl;
  cout << "p[3] val is : " << *(p + 3) << endl;
  cout << "p[4] val is : " << *(p + 4) << endl;
}

void ptr_arr() {

  char a;
  cout << "sizeof(char) = " << sizeof(char) << endl; // 1 字节
  cout << "  > a 的地址是：" << (void *)&a << endl;
  cout << "  > a 的地址+1 是：" << (void *)(&a + 1) << endl;
  short b;
  cout << "sizeof(short) = " << sizeof(short) << endl; // 2 字节
  cout << "  > b 的地址是：" << &b << endl;
  cout << "  > b 的地址+1 是：" << (&b + 1) << endl;
  int c;
  cout << "sizeof(int) = " << sizeof(int) << endl; // 4 字节
  cout << "  > c 的地址是：" << &c << endl;
  cout << "  > c 的地址+1 是：" << (&c + 1) << endl;
  double d;
  cout << "sizeof(double) = " << sizeof(double) << endl; // 8 字节
  cout << "  > d 的地址是：" << &d << endl;
  cout << "  > d 的地址+1 是：" << (&d + 1) << endl;
}

//------------------------------------------------------------------------
// 数组使用相关
//------------------------------------------------------------------------

// 创建数组
void create_array() {

  // 声明一个数组
  int arr[3];
  string names[3];

  // 给数据赋值，数组下表从0 开始
  for (int i = 0; i < 3; i++) {
    arr[i] = i + 10;
    names[i] = "for-" + to_string(i);
  }
}

// 数组的数据内存
void mem_arr() {}

// 数据的初始化
void init_arr() {

  // 数组的初始化 1
  int arr1[3] = {2, 4, 5};
  // 初始化按照顺序赋值，不足的以 0 补全
  int arr2[5] = {3, 4, 5};
  // 不写数组长度，按照赋值的长度作为数组的长度
  int arr3[] = {1, 2, 3, 4, 3, 5};

  // 可以将数组直接赋予 0 作为初始值
  int arr5[5] = {0};
  int arr4[5] = {}; // 0 可以不写
  //

  for (int i = 0; i < (sizeof(arr3) / sizeof(int)); i++) {
    cout << arr3[i] << endl;
  }

  // 直接对数组进行循环输出数据
  for (int i = 0; i < 5; i++) {
    cout << "string:: = " << arr5[i] << endl;
  }
}

// 清空数组
// void * memset(void *s, int c, size_t n);
// Linux 下使用 memcpy() 需要包含头文件 <sting.h>
void clear_arr() {

  int arr3[] = {1, 2, 3, 4, 3, 5};

  for (int i = 0; i < (sizeof(arr3) / sizeof(int)); i++) {
    cout << arr3[i] << endl;
  }
  memset(arr3, 0, sizeof(arr3));

  for (int i = 0; i < (sizeof(arr3) / sizeof(int)); i++) {
    cout << arr3[i] << endl;
  }
}

// 复制数组
void copy_arr() {

  int arr3[] = {1, 2, 3, 4, 3, 5};
  // 声明一个大小一样的数组
  int arr4[(sizeof(arr3) / sizeof(int))];
  // 进行数据拷贝
  memcpy(arr4, arr3, sizeof(arr3));

  for (int i = 0; i < (sizeof(arr4) / sizeof(int)); i++) {
    cout << "arr3 = " << arr3[i] << ", arr4 = " << arr4[i] << endl;
  }
}

//
int main() {
  cout << "------------>> test of array <<-----------------" << endl;

  // 创建数组并赋值
  create_array();

  // 初始化数组
  init_arr();

  // 清空数组
  clear_arr();

  // 数组拷贝
  copy_arr();

  // 数组指针地址规律
  ptr_arr();

  // 数组指针的本质
  ptr_tran_index();

  // 数组的越界
  out_of_index();

  // new-delete
  new_delete();

  // sort
  sort_func();

  cout << "------------>> ends of array <<-----------------" << endl;
}
